<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hkb blog</title>
  
  
  <link href="https://hkbweb.github.io/atom.xml" rel="self"/>
  
  <link href="https://hkbweb.github.io/"/>
  <updated>2021-01-08T17:11:19.530Z</updated>
  <id>https://hkbweb.github.io/</id>
  
  <author>
    <name>hkbweb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PS按钮制作</title>
    <link href="https://hkbweb.github.io/posts/59355/"/>
    <id>https://hkbweb.github.io/posts/59355/</id>
    <published>2021-01-08T15:08:25.000Z</published>
    <updated>2021-01-08T17:11:19.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><label><ul><li>在PS里新建一个<code>10厘米*10厘米</code>的图片</li><li>在工具箱选择<code>圆角矩形工具</code></li><li>在属性栏修改圆角矩形的<code>半径</code>在80左右<img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS1.png"></li><li>先在图片上单击滑动</li><li>滑动之后按住SHITF键画出方形</li><li>拖动画出的圆角矩形并居中</li><li>双击图层栏里的圆角矩形打开<code>图层样式</code></li><li>选中<code>斜面和浮雕</code></li><li>在阴影选项中将<code>全局光</code>去掉</li><li>并将上面的改为<code>90度</code></li><li>下方<code>阴影模式</code>不透明度适当降低</li><li>在上方的结构选项中的最后一项适当的加上软化<img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS2.png"></li></ul></label><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><label><ul><li>在左边工具栏中的<code>矩形工具</code>中选择<code>椭圆工具</code></li><li>滑动之后按住SHITF键画圆型</li><li>拖动圆形并居中</li><li>双击圆形打开<code>图层样式</code></li><li>勾选<code>描边</code></li><li>结构中的大小改为<code>8像素</code></li><li><code>填充类型</code>的颜色改为白色<img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS3.png"></li><li>勾选<code>内阴影</code></li><li>去掉<code>全局光</code></li><li>角度改为<code>90度</code></li><li>大小适当的提高</li><li>再适当改一下不透明度<img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS4.png"></label></li></ul><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><label><ul><li><p>选择圆形2<code>复制一层</code></p></li><li><p>按下<code>CTRL+T</code>修改图形大小</p></li><li><p>同时按下<code>SHIFT+ALT</code>并滑动鼠标缩小圆形    </p><blockquote><p>按下回车确定（如果不满意图形大小可以不按确定按ESC）</p></blockquote></li><li><p>选择圆形2双击打开<code>图层样式</code></p></li><li><p>勾选<code>渐变叠加</code></p></li><li><p>双击渐变的中间打开<code>渐变编辑器</code></p></li><li><p>双击下方的两个小脚来改变颜色</p><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS5.png"><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS6.png"></li><li><p>点击确定之后返回到图层样式</p></li><li><p>点击<code>内阴影</code></p></li><li><p>将颜色改为同色系的深色</p></li><li><p>再调一下不同明度，调高一点</p><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS7.png"></li></ul></label><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><label><ul><li>选择圆形2复制一层</li><li>按下<code>CTRL+T</code>修改图形大小</li><li>同时按下<code>SHIFT+ALT</code>并滑动鼠标缩小圆形    </li><li>按下回车确定（如果不满意图形大小可以不按确定按ESC）</li><li>选择圆形3双击打开<code>图层样式</code></li><li>取消<code>内阴影和颜色叠加</code></li><li>勾选<code>投影</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS8.png"></li><li>更改颜色为<code>同色系深色</code></li><li>适当修改距离、扩展、和大小</li><li>最后修改下不透明度</li></ul></label><h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><label><ul><li>在左边工具矩形工具中选择<code>自定义工具</code></li><li>点击形状右边的<code>下拉栏</code></li><li>打开之后点击<code>齿轮点击全部</code></li><li>选择对应的工具来画圆型<img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS9.png"></li><li>画好之后在左边的工具矩形工具中选择<code>矩形工具</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS10.png"></li><li>在顶部属性栏选择<code>减去顶层形状</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS11.png"></li><li>按<code>CTRL+R</code>打开标尺</li><li>在上面标尺处按住鼠标下来到图形的中间</li><li>在左边标尺处按住鼠标右移至图形的中间</li><li>在标尺线的右上方滑动一个矩形去掉圆形的<code>四分之一</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS12.png"></li><li>画好之后在左边的工具矩形工具中选择<code>椭圆工具</code></li><li>在顶部属性栏选择<code>合并形状</code></li><li>在圆边矩形处添加<code>两个圆形填充</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS13.png"></li><li>如果填充的圆形大小不合适可以按下<code>CTRL+T</code>来变换掉</li><li>如果想拖动位置可以选择左边工具栏矩形工具上方的<code>路径选择工具</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS14.png"></li><li>弄好之后在上方属性栏点击<code>合并形状组件</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS15.png"></li></ul></label><h1 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h1><label><ul><li>将图形2的的图层样式复制到最新的图层</li><li><code>鼠标长按图层样式并按住ALT拖动至最新图层</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS16.png"></li><li>选择图形4然后按下<code>CTRL+T</code>将图层摆正</li><li>按下<code>回车</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS17.png"></li><li>选择圆形4双击打开<code>图层样式</code></li><li>将<code>内阴影</code>去掉</li><li>勾选<code>内发光</code></li><li>选择<code>内发光</code></li><li>混合模式改为<code>正片叠底</code></li><li>颜色选择<code>同色深色系</code></li><li>修改一下不透明度和大小即可<img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS18.png"></li></ul></label><h1 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h1><label><ul><li>在左边工具矩形工具中选择<code>椭圆工具</code><img src= "/img/loading.gif" data-lazy-src="/img/PS2/PS19.png"></li><li>画出一个<code>长条形</code></li><li>将刚刚的图层样式复制到这里</li><li><code>鼠标长按图层样式并按住ALT拖动至最新图层</code></li><li>选择图形5然后按下<code>CTRL+T</code>将图层摆正</li></ul><blockquote><p>最后微调一下即可</p></blockquote></label>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="PS" scheme="https://hkbweb.github.io/categories/PS/"/>
    
    
    <category term="PS" scheme="https://hkbweb.github.io/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>STM32获取按钮</title>
    <link href="https://hkbweb.github.io/posts/31770/"/>
    <id>https://hkbweb.github.io/posts/31770/</id>
    <published>2021-01-06T12:59:00.000Z</published>
    <updated>2021-01-06T13:01:06.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/categories/STM32/"/>
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>PS人物精修</title>
    <link href="https://hkbweb.github.io/posts/29970/"/>
    <id>https://hkbweb.github.io/posts/29970/</id>
    <published>2021-01-05T13:26:10.000Z</published>
    <updated>2021-01-06T02:09:54.490Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><label>   <h3> 导入人物图片</h3>  <h3>  在左边工具栏选择仿制图章先将图片水印去掉</h3>   <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS1.png">   <h3> 按住ALT并滑动滚轮放大图片，然后按ALT键取样点</h3>   <h3> 然后用鼠标左边将水印擦掉</h3>   <h3>在左边工具栏选择污点修复工具里面的修复换工具修复人物的污点</h3>    <h3>按ALT键取样点</h3>    <h3>然后按住ALT键取样点之后用鼠标左键修复有水印的地方</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/1.gif"><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1>  <label>    <h3> 在右边控制面板</h3>    <h3> 选择通道面板</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS2.png">    <h3> 分别点击红绿蓝查看明暗对比最强烈的通道</h3>    <h3> 右键复制图层</h3>    <h3> 点击复制图层</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS3.png">  </label><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><label>    <h3>在菜单栏选择滤镜-其他-高反差保留-半径里填入8像素或者10像素</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS4.png">    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS5.png">     <h3>在菜单栏选择图像-计算</h3>     <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS6.png">    <h3>最下面的混合选择强光,点击确定</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS7.png">    <h3>再重复计算两次一共3次计算</h3>    <h3>选择Alpha3</h3>    <h3>先按照CTRL然后同时按鼠标左键选择区域或者点击下方的“将通道作为选区载入”</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS8.png">   <h3> 选好选区之后</h3>   <h3> 在菜单栏-选择,点击反选或者同时按SHIFT+CTRL+I</h3>   <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS9.png"></label><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><label>     <h3>单击通道面板下方的RGB图层</h3>     <h3>然后点击通道左边的图层面板</h3>     <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS10.png">     <h3>点击图层面板上方的调成面板里面的曲线</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS11.png">     <h3>根据实际情况调整曲线</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS12.png"></label><h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><label>    <h3>复制一层人物图层并置顶或者用鼠标按住图层拖到最上方</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS13.png">    <h3>在菜单栏-滤镜-模糊-表面模糊</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS14.png">   <h3> 半径选择15阈值选择20点击确定</h3>   <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS15.png">    <h3>并将图层的不透明度调低</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS16.png">    <h3>再次复制一层人物图层并置顶或者用鼠标按住图层拖到最上方</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS17.png">    <h3>在菜单栏-滤镜-其他-高反差保留</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS18.png">    <h3>半径选择1或者0.8点击确定</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS19.png">    <h3>混合模式选择线性光</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS20.png"></label><h1 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h1><label>    <h3>在上方的调整面板选择可选颜色</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS21.png">    <h3>根据实际情况调整红色-黄色-中性色</h3>    <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS22.png"></label><h1 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h1><label>     <h3>选择左边工具箱的套索工具或者钢笔工具</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS23.png">     <h3>选择要提亮颜色的位置,并选择羽化</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS24.png">     <h3>点击新建图层</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS25.png">     <h3>填充对应的颜色</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS26.png">      <h3> 选择正片叠底</h3>        <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS27.png">     <h3>双击选择的图层，打开图层样式</h3>     <h3>选择混合选择：自定</h3>     <h3>选择最下方的混合颜色带里面的下个图层</h3>     <h3>在白色区域鼠标点击尖角并按住ALT</h3>     <h3>拖动鼠标看实际效果</h3>      <img src= "/img/loading.gif" data-lazy-src="/img/PS1/PS28.png"><label><h1 id="如果还有其他区域重复第七步步骤"><a href="#如果还有其他区域重复第七步步骤" class="headerlink" title="如果还有其他区域重复第七步步骤"></a>如果还有其他区域重复第七步步骤</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="PS" scheme="https://hkbweb.github.io/categories/PS/"/>
    
    
    <category term="PS" scheme="https://hkbweb.github.io/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>Collection、泛型</title>
    <link href="https://hkbweb.github.io/posts/1/"/>
    <id>https://hkbweb.github.io/posts/1/</id>
    <published>2020-12-31T12:03:38.000Z</published>
    <updated>2021-01-06T12:54:32.260Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Collection集合</li><li>迭代器</li><li>增强for</li><li>泛型</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li><li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li><li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li><li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li><li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li><li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li><li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li><li><input disabled="" type="checkbox"> 能够理解泛型上下限</li><li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li></ul><h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src= "/img/loading.gif" data-lazy-src="img%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png"></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建集合对象 </span></span><br><span class="line">    <span class="comment">// 使用多态形式</span></span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 使用方法</span></span><br><span class="line">    <span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    Object[] objects = coll.toArray();</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">System.out.println(objects[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void  clear() 清空集合</span></span><br><span class="line">coll.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line"><span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">System.out.println(coll.isEmpty());  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src= "/img/loading.gif" data-lazy-src="img%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       <span class="comment">//使用增强for遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    <span class="comment">//使用增强for遍历</span></span><br><span class="line">    <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);     </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p></li></ul><ul><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">&quot;♥&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♣&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">&quot;小☺&quot;</span>);</span><br><span class="line">        pokerBox.add(<span class="string">&quot;大☠&quot;</span>);  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;田伯光：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;绿竹翁：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://hkbweb.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STM32创建文件目录</title>
    <link href="https://hkbweb.github.io/posts/1456/"/>
    <id>https://hkbweb.github.io/posts/1456/</id>
    <published>2020-12-27T15:09:00.000Z</published>
    <updated>2021-01-06T03:15:24.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>新建一个文件夹<br>lesson_fwlib_template<br>里面新建以下文件</p><p>   Projecr：工程</p><p>   Libraries：固件库</p><p>   User：用户编写</p><p>   Doc:说明文件</p><p>第一步<br>   打开keli5<br>   点击project<br>   new vision project<br>   选择刚刚新建的文件位置<br>   选择project<br>   在下面文件名输入“自定义文件名”<br>   确定之后选择STMicroelectronics前面的＋号<br>   根据自己的型号选择芯片型号，比如我的是stm32f103rct6<br>   点击STM32F1 Series前面的+号<br>   点击STM32F103前面的+号<br>   选择STM32F103RC<br>   点击ok<br>   弹出的框点击关闭</p><p>第二步<br> 在左侧Project拦里面的target 1文件夹下<br> 双击Source Group1更改名称为STARTUP<br> 右键Target1 点击Add Group更改名称为CMSIS用于存放<br>  右键Target1 点击Add Group更改名称为FWLIB用于存放固件库<br>  右键Target1 点击Add Group更改名称为USER用于存放用户文件<br>  右键Target1 点击Add Group更改名称为DOC用于存放文件说明</p><p>第三步<br>  打开用于存放的文件的文件夹<br>  打开Libraries文件夹<br>  再打开官方文件STM32F10x_StdPeriph_Lib_V3.5.0\Libraries<br>  将CMSIS、STM32F10x_StdPeriph_Driver<br>  一起复制到自己存放Libraries的文件<br>  打开\Libraries\CMSIS删除多余的文件<br>  删除License.doc<br>  删除CMSIS_changes.htm<br>  删除CMSIS debug support.htm<br>  删除Documentation<br>  CMSIS文件里只剩下CM3<br>  打开CM3\DeviceSupport\ST\STM32F10x<br>  将里面所有的文件剪切到CMSIS<br>  进入CM3文件夹删除DeviceSupport<br>  打开CoreSupport文件夹<br>  将里面的所有文件剪切到CMSIS<br>  删除CM3<br>  最后CMSIS文件夹只剩下<br>  srartup文件夹<br>  core_cm3.c<br>  core_cm3.h<br>  stm32f10x.h<br>  system_stm32f10x.c<br>  system_stm32f10x.h<br>  这几个文件夹<br>  打开srartup文件夹<br>  删除gcc_ride7/iar/TrueSTUDIO<br>  打开arm文件夹将里面的文件剪切到之前的目录startup<br>  删除arm</p><p>第四步<br>   返回到文件目录打开User<br>   右键新建文本文档<br>   改名为main.c<br>   再打开官方文件STM32F10x_StdPeriph_Lib_V3.5.0\Project<br>   复制<br>   stm32f10x_conf.h<br>   stm32f10x_it.c<br>   stm32f10x_it.h<br>   到User目录里面</p><p>第五步<br>   回到keli5双击Project里面的STARTUP将启动文件加进去<br>   点击文件类型选All files（*.*）<br>   返回到上级目录<br>   打开Libraries/CMSIS/startup<br>   根据芯片型号选择文件，我的是RCT6-256k<br>   我选择startup_stm32f10x_hd.s<br>   点击add添加然后点击Close关闭</p><p>   回到keli5双击Project里面的CMSIS<br>   返回到上级目录CMSIS<br>   添加core_cm3.c、system_stm32f10x.c<br>   分别添加进去然后点击Close关闭</p><p>   回到keli5双击Project里面的FWLIB<br>   返回到上级目录Libraries<br>   打开STM32F10x_StdPeriph_Driver/src<br>   按Ctrl+A全选点击add添加进来<br>   然后点击Close关闭</p><p>   回到keli5双击Project里面的USER<br>   返回到上级根目录<br>   打开User<br>   添加main.c、stm32f10x_it.c<br>   分别添加进去然后点击Close关闭</p><p>   回到keli5双击Project里面的DOC<br>   返回到上级根目录<br>   打开Doc<br>   添加readme.txt添加进去然后点击Close关闭</p><p>第六步<br>   打开魔术棒选项卡Options for Target<br>   选择C/C++<br>   选择倒数第三个文本框include paths<br>   点击后面的。。。按钮<br>   点击（x）左边的新建按钮<br>   点击刚出现的文本后面。。。按钮<br>   打开Libraries\CMSIS点击选择文件夹之后按回车确定<br>   点击（x）左边的新建按钮<br>   点击刚出现的文本后面。。。按钮<br>   打开Libraries\STM32F10x_StdPeriph_Driver\inc点击选择文件夹之后按回车确定<br>   点击（x）左边的新建按钮<br>   点击刚出现的文本后面。。。按钮<br>   打开User点击选择文件夹之后按回车确定<br>   点击ok再次点击ok返回到界面</p><p>第七步<br>   点击user的加号打开mian.c<br>   对#include “stm32f10x.h”右键open document”stm32f10x.h”<br>   将文件翻到倒最底下再往上一点复制USE_STDPERIPH_DRIVER<br>   打开魔术棒选项卡Options for Target<br>   选择C/C++<br>   在第一个define文本框里面粘贴<br>   点击ok<br>   将stm32f10x.h文件翻到倒最顶部往下滑一些<br>   找到!defined<br>   复制自己对应型号容量的文件名称<br>   打开魔术棒选项卡Options for Target<br>   选择C/C++<br>   在第一个define文本框内<br>   在后面添加英文状态下逗号（,）粘贴进去</p><p>第八步<br>   打开魔术棒选项卡Options for Target<br>   选择Target右边Code Generation<br>   勾上Use MicroLIB<br>   选择Output<br>   下边勾上Create HEX File和Browes information</p><p>第九步<br>   进入文件根目录新建一个文本文档<br>   输入<br>   del *.bak /s<br>   del *.ddk /s<br>   del *.edk /s<br>   del *.lst /s<br>   del *.lnp /s<br>   del *.mpf /s<br>   del *.mpj /s<br>   del *.obj /s<br>   del *.omf /s<br>   del *.plg /s<br>   del *.rpt /s<br>   del *.tmp /s<br>   del *.__i /s<br>   del *.crf /s<br>   del *.o /s<br>   del *.d /s<br>   del *.axf /s<br>   del *.tra /s<br>   del *.dep /s<br>   del *.JLinkLog.txt /s<br>   del *.iex /s<br>   del *.htm /s<br>   del *.sct /s<br>   del *.map /s<br>   exit<br>   保存之后将文本名字改为keli.bat</p><p>第十步</p><p>   将ST-LINK2插入电脑<br>   用杜邦线链接单片机<br>   ST-LINK的CLK对单片机的CLK，DIO对着单片机的DIO<br>   如果单片机单独供电则只将ST-LINK2的GND接上单片机的GND<br>   如果不是单独供电则将ST-LINK2的3.3V和GND接上单片机的3.3V和GND<br>   回到keli5<br>   打开魔术棒选项卡Options for Target<br>   选择Debug右边区域的Use选择ST-Link Debugger<br>   点击右边Settings<br>   将下方Target Com的Port选择为SW<br>   右方区域SW DeVice可以识别到ST-LINK2下载器<br>   如果右方区域没有显示无则是ST-LINK2有问题<br>   选择Flash Dowload选择下方Dowload Function<br>   勾上Reset and Run<br>   点击确定退出再次点击ok表示完成<br>   编译程序之后<br>   按F8或者点击DOWNLOAD下载程序</p><p>错误解决</p><p> 1、coer_cm3.c文件错误，4次警告以上，跟着教程还是一样<br>   （报错的原因是Coer_cm3.c和Coer_cm3.h文件太老导致的，这个是2009版本，ST已经停止维护了）<br> 解决方法：1、更换解决方案版本，将6变成5<br>          打开魔术棒工具<br>          点击Target<br>          选择右边Code Generation<br>          ARM Compiler：选择Use default compiler version 5这个版本</p><pre><code>     2、下载最新的STM32cube_FW软件包        删除之前的旧文件        打开压缩包将cmsis_armcc_V6.h、core_cm3.h、coer_cmFunc.h、coer_cmlnstr.h这几个文件覆盖到CMSIS里面。停用core_cm3.c改用CMSIS标准接口。        这是ARM官方标准接口，坏处是CMSIS标准接口屏蔽了实现细节，但这是趋势。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/categories/STM32/"/>
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>STM32开发</title>
    <link href="https://hkbweb.github.io/posts/1455/"/>
    <id>https://hkbweb.github.io/posts/1455/</id>
    <published>2020-12-27T15:09:00.000Z</published>
    <updated>2020-12-28T11:28:35.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STM32学习过程"><a href="#STM32学习过程" class="headerlink" title="STM32学习过程"></a>STM32学习过程</h1><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p> <code>修改STM32寄存器单个位值</code></p><p>GPIOB_ODR的第10位置一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GPIOB_ODR的第10位置一</span></span><br><span class="line">GPIOB_ODR | = (<span class="number">1</span>&lt;&lt;<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>（  |  ）或符号任何数用于对比时等于任何数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">//基础数值</span></span><br><span class="line">| <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span><span class="comment">//用（或）改变单位数值</span></span><br><span class="line">= <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span><span class="comment">//等于的数值</span></span><br></pre></td></tr></table></figure><p>GPIOB_ODR的第10位<code>清零</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GPIOB_ODR的第10位置一</span></span><br><span class="line">GPIOB_ODR &amp; = ~(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>(  |  )与符号<br>( &amp; ) 取反符号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="comment">//基础数值</span></span><br><span class="line">~ <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span><span class="comment">//取反</span></span><br><span class="line">&amp; <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span><span class="comment">//用（与）改变单位数值</span></span><br><span class="line">= <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span><span class="comment">//等于的数值</span></span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;<span class="comment">//定义一个32位的地址</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint16_t</span>;<span class="comment">//定义一个16位的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//定义类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> CRL;  <span class="comment">//定义一个32位的地址名字为CRL </span></span><br><span class="line"><span class="keyword">uint32_t</span> CRH;  <span class="comment">//定义一个32位的地址名字为CHR</span></span><br><span class="line"><span class="keyword">uint32_t</span> IDR;  <span class="comment">//定义一个32位的地址名字为IDR</span></span><br><span class="line"><span class="keyword">uint32_t</span> ODR;  <span class="comment">//定义一个32位的地址名字为ODR</span></span><br><span class="line"><span class="keyword">uint32_t</span> BSRR; <span class="comment">//定义一个32位的地址名字为BSRR</span></span><br><span class="line"><span class="keyword">uint32_t</span> BRR;  <span class="comment">//定义一个32位的地址名字为BRR </span></span><br><span class="line"><span class="keyword">uint32_t</span> LCKR; <span class="comment">//定义一个32位的地址名字为LCKR</span></span><br><span class="line">&#125;GPIO_TypeDef;<span class="comment">//定义的名字</span></span><br></pre></td></tr></table></figure><p>结构类型转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB  ((GPIO_TypeDef*)GPIOB_BASE)<span class="comment">//宏定义GPIOB指向内存</span></span></span><br></pre></td></tr></table></figure><h3 id="三级目录"><a href="#三级目录" class="headerlink" title="三级目录"></a>三级目录</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/categories/STM32/"/>
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>STM32点亮led</title>
    <link href="https://hkbweb.github.io/posts/1457/"/>
    <id>https://hkbweb.github.io/posts/1457/</id>
    <published>2020-12-27T15:09:00.000Z</published>
    <updated>2021-01-06T12:58:33.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一步<br>   复制一份文件STM32模本文件<br>   打开文件目录<br>   进入User文件新建一个bsp_led.c和bsp_led.h<br>   返回到根目录打开projecr进入之后打开工程<br>   双击USER添加刚刚的bsp_led.c文件进来</p><p>第二步<br>   双击bsp_led.c在里面输入#include “bsp_led.h”<br>   打开魔术棒选项卡Options for Target<br>   点击C/C++选择下面include Paths后面的三个点<br>   将bsp_led.h的文件目录添加进去</p><p>第二步<br>   右键#include “bsp_led.h”选择open document”bsp_led.h”<br>   在里面添加<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BSP_LED_H                             <span class="comment">//防止被多个文件多次调用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BSP_LED_H                             <span class="comment">//定义宏</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span>                          <span class="comment">//调用STM32头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G_GPIO_PIN     GPIO_Pin_0           <span class="comment">//定义宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G_GPIO_PORT    GPIOB                <span class="comment">//定义宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G_GPIO_CLK     RCC_APB2Periph_GPIOB <span class="comment">//定义宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ON   1                                  <span class="comment">//定义宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFF  0                                  <span class="comment">//定义宏</span></span></span><br><span class="line"><span class="comment">//定义带参数的宏</span></span><br><span class="line"><span class="comment">//定义带条件判断的宏</span></span><br><span class="line"><span class="comment">//C语言续行符，后面不能有任何的东西</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G(a)   <span class="meta-keyword">if</span>(a) \</span></span><br><span class="line">                      GPIO_SetBits(LED_G_GPIO_PORT, LED_G_GPIO_PIN);\<span class="comment">//\是换行符，换行之后后面不能带任何字符或者符号</span></span><br><span class="line">                  <span class="keyword">else</span> GPIO_ResetBits(LED_G_GPIO_PORT, LED_G_GPIO_PIN);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">LED_GPIO_Config</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//引用参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*__BSP_LED_H8*/</span><span class="comment">//结束</span></span></span><br></pre></td></tr></table></figure><br>第三步<br>    在bsp_led.c里面添加<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//定义引用参数</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">LED_GPIO_Config</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line"> GPIO_InitTypeDef  GPIO_InitSruct;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(LED_G_GPIO_CLK, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitSruct.GPIO_Pin     =   LED_G_GPIO_PIN;  </span><br><span class="line">GPIO_InitSruct.GPIO_Mode    =    GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitSruct.GPIO_Speed   =   GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(LED_G_GPIO_PORT , &amp;GPIO_InitSruct);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>第四步<br>   在main.c里面添加<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bsp_led.h&quot;</span>   <span class="comment">//调用文件</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//只能包含.h的头文件</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">uint32_t</span> count)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;count!=<span class="number">0</span>;count--);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">LED_GPIO_Config();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//GPIO_SetBits(LED_G_GPIO_PORT, LED_G_GPIO_PIN);</span></span><br><span class="line">LED_G(ON);</span><br><span class="line">    Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">    <span class="comment">//GPIO_ResetBits(LED_G_GPIO_PORT, LED_G_GPIO_PIN);</span></span><br><span class="line">LED_G(OFF);</span><br><span class="line">Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  s&#125;</span><br></pre></td></tr></table></figure></p><p>这次学习到了<br>1、在.h里面如果有==重复编译==或者调用的头文件则需要添加“条件编译宏”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  __函数    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  __函数</span></span><br><span class="line"></span><br><span class="line">宏或者调用文件</span><br><span class="line"><span class="comment">//定义类型    自定宏名称  宏对应参数或者对应的GPIo.h参数表</span></span><br><span class="line"><span class="comment">//        定义GPIO的接口     接口为0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G_GPIO_PIN     GPIO_Pin_0</span></span><br><span class="line"><span class="comment">//        定义GPIO类型      接口几</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G_GPIO_PORT    GPIOB</span></span><br><span class="line"><span class="comment">//        定义GPIO定时器     定时器位置和类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G_GPIO_CLK     RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定参数  定义名称 数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ON   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFF  0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义判断</span></span><br><span class="line"><span class="comment">//C语言续行符，后面不能有任何的东西</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_G(a)   <span class="meta-keyword">if</span>(a) \</span></span><br><span class="line">                        GPIO_SetBits(LED_G_GPIO_PORT, LED_G_GPIO_PIN);\</span><br><span class="line">                     <span class="keyword">else</span> GPIO_ResetBits(LED_G_GPIO_PORT, LED_G_GPIO_PIN);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  结束</span></span><br></pre></td></tr></table></figure><p>1.1在.h的文件里面如果要使用GPIO口则要在宏定义添加“stm32f10x.h”</p><p>1.2初始化外设则需要初始化结构体，将函数名称复制到.c的调用函里面</p><p>2、如果要使用GPIO口则要在“stm32f103_gpio.h”里面寻找函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//函数类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;<span class="comment">//函数名称</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化接结构体</span></span><br><span class="line"><span class="comment">//结构体          自定结构体名称</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct</span><br><span class="line"><span class="comment">//开启APb2总线的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(LED_G_GPIO_CLK, ENABLE);</span><br><span class="line"><span class="comment">//定义使用的GPIO口</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = LED_G_GPIO_PIN;</span><br><span class="line"><span class="comment">//定义GPIO口模式设置为推挽输出</span></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"><span class="comment">//p配置接口速度为50MHZ</span></span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"><span class="comment">//配置端口以及位置，配置指针如果是变量则输入&amp;来指向内存地址</span></span><br><span class="line">GPIO_Init(LED_G_GPIO_PORT , &amp;GPIO_InitStruct);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、新建调用函数这需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> 参数 （<span class="keyword">void</span>）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、如果想要开启某个端口或者操作某个位置可以在GPOI.H里面找，每个函数就像调用一样只要初始化函数就可以使用里面的函数</p><p>5、如果想找某个函数的原型可以按F12或者右键GO过去</p><p>6、如想控制两个以上的GPIO口需要定义之后再次初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择要控制的GPIO引脚*/</span></span><br><span class="line"><span class="comment">/*调用库函数，初始化GPIO*/</span></span><br><span class="line">GPIO_InitSruct.GPIO_Pin  =  LED_R_GPIO_PIN;</span><br><span class="line">GPIO_Init(LED_GPIO_PORT , &amp;GPIO_InitSruct);</span><br><span class="line">   <span class="comment">/*选择要控制的GPIO引脚*/</span></span><br><span class="line"><span class="comment">/*调用库函数，初始化GPIO*/</span></span><br><span class="line">GPIO_InitSruct.GPIO_Pin  =  LED_G_GPIO_PIN;</span><br><span class="line">GPIO_Init(LED_GPIO_PORT , &amp;GPIO_InitSruct);</span><br><span class="line"><span class="comment">/*选择要控制的GPIO引脚*/</span></span><br><span class="line"><span class="comment">/*调用库函数，初始化GPIO*/</span></span><br><span class="line">GPIO_InitSruct.GPIO_Pin  =  LED_B_GPIO_PIN;</span><br><span class="line">GPIO_Init(LED_GPIO_PORT , &amp;GPIO_InitSruct);</span><br></pre></td></tr></table></figure><p>7、写完之后在main.c调用sep_led.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只能包含.h的头文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">uint32_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;count!=<span class="number">0</span>;count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化调用函数</span></span><br><span class="line">LED_GPIO_Config();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> LED_R(ON);</span><br><span class="line">    Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">LED_R(OFF);</span><br><span class="line">  Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">        LED_G(ON);</span><br><span class="line">Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">        LED_G(OFF);</span><br><span class="line">Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">LED_B(ON);</span><br><span class="line">Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line">LED_B(OFF);</span><br><span class="line">Delay(<span class="number">0xFFFFF</span>);</span><br><span class="line"><span class="comment">//GPIO_SetBits(LED_GPIO_PORT, LED_B_GPIO_PIN);</span></span><br><span class="line"><span class="comment">//GPIO_ResetBits(LED_GPIO_PORT, LED_B_GPIO_PIN);</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 待修改</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/categories/STM32/"/>
    
    
    <category term="STM32" scheme="https://hkbweb.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="https://hkbweb.github.io/posts/45069/"/>
    <id>https://hkbweb.github.io/posts/45069/</id>
    <published>2020-12-26T18:39:00.000Z</published>
    <updated>2021-01-06T02:08:50.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>欢迎来到我的博客，这是 <a href="https://hexo.io/">Hexo</a>主题</p><h2 id="祝贺我离开这里"><a href="#祝贺我离开这里" class="headerlink" title="祝贺我离开这里"></a>祝贺我离开这里</h2><p>这是我的第一个博客，在安装的过程中走了很多弯路</p><p>在得知我的小伙伴制作了一个博客之后，我的心也蠢蠢欲动。</p><p>在询问了我的小伙伴制作方法之后我就开始了我的博客制作之路</p><h5>先是安装了Git、Node.js、Hexo这些软件</h5><h5>更换主题</h5><h5>然后注册Github账号添加</h5><h5>使用ssh制作秘钥</h5><h5>然后就是域名解析</h5><h5>就简单的讲述一下吧</h5><h5>目前还有很多问题没有解决</h5><h5>比如加载动画不明不买的没了、或者主题美化不知道为什么没有用，看不懂代码如何引用。抄代码时出现错误</h5><img src= "/img/loading.gif" data-lazy-src="/img/pic.jpg"><h4 id="最后感谢一下这几位的博客主题美化的链接"><a href="#最后感谢一下这几位的博客主题美化的链接" class="headerlink" title="最后感谢一下这几位的博客主题美化的链接"></a>最后感谢一下这几位的博客主题美化的链接</h4><p><a href="https://www.antmoe.com/posts/a811d614/index.html">小康博客</a></p><p><a href="https://www.linuxwf.com/2020/04/08/exo-theme-butterfly-%E5%AE%89%E8%A3%9D%E6%96%87%E6%AA%94%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%BB%E9%A1%8C%E9%85%8D%E7%BD%AE/#%E7%B6%B2%E7%AB%99%E5%89%AF%E6%A8%99%E9%A1%8C">WF’s blog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="hexo" scheme="https://hkbweb.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://hkbweb.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
